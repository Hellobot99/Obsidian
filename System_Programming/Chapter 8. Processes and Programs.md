# 프로그램 vs 프로세스

- **프로그램**: 저장된 파일. 명령어(코드)와 데이터의 모음.
    
- **프로그램 실행**: CPU가 그 명령어(절차)를 따라 실제로 수행하는 것.
    
- **실행 가능한 프로그램**: 컴파일된 바이너리 파일 (명령어 + 데이터).
    
- **프로세스**: 메모리 공간 + 프로그램을 실행하기 위한 각종 정보(PID, 레지스터 상태, 열린 파일 등).

# 프로세스의 메모리 구성

- 메모리 공간은 4개 영역으로 나뉜다:
    
    1. Text (코드 영역)
        
    2. Data (초기화된 전역변수)
        
    3. Heap (동적 메모리, malloc 등)
        
    4. Stack (함수 호출 시 지역변수, 리턴 주소 저장)
        
- **각 프로세스는 독립된 고유한 주소 공간을 가짐.**
    

---

# 프로그램 → 프로세스 되는 과정

- 프로그램과 데이터는 디스크에 저장됨.
    
- 커널이 프로그램 코드를 메모리에 복사하거나,
    
- CPU가 명령어를 실행하기 시작하면,  
    **프로그램이 프로세스가 된다.**
    

---

# User Space

- **User Space**: 커널 스페이스와 분리된 영역. 사용자 프로그램이 실행되는 메모리 공간.
    
- ps 명령어로 User Space에 존재하는 프로세스들을 볼 수 있다.
    
- ps 옵션:
    
    - `-a`: 다른 사용자, 다른 터미널 프로세스도 보여줌
        
    - `-l`: 더 자세한 정보(long format) 표시

---

# PID와 PPID

- **PID**: 모든 프로세스는 고유한 프로세스 ID를 가짐.
    
- **PPID**: 모든 프로세스는 자신을 만든 부모 프로세스를 가짐.

---

# 파일 vs 프로세스

|항목|파일|프로세스|
|---|---|---|
|저장 위치|디스크|메모리|
|역할|데이터 저장|코드 실행|
|생성/삭제 주체|커널|커널|

---

# Shell

- Shell = 운영체제 서비스에 접근할 수 있는 사용자 인터페이스.
    
- Shell은 다른 프로그램을 실행하거나, 관리할 수 있다.
    

**Shell의 3가지 주요 기능:**

1. 프로그램 실행
    
    - 사용자 명령 해석 → 프로그램을 메모리에 올리고 실행.
        
2. 입출력 관리 (I/O Redirection)
    
    - `>`, `<`: 파일과 프로그램 간 입출력 방향 조정
        
    - `|`: 프로세스 간 데이터를 연결 (파이프)
        
3. 프로그래밍 가능
    
    - Shell 스크립트로 명령어 자동화 및 재사용 가능.
        

---

# Shell 동작 순서

1. 사용자로부터 명령 입력 받음
    
2. 새 프로세스를 생성 (fork)
    
3. 디스크에서 프로그램을 메모리에 로드 (exec)
    
4. 프로그램 실행
    
5. 명령어가 끝나면 다시 반복
    

---

# execvp()

- **현재 프로세스 이미지를 새로운 프로그램으로 교체**함.
    
- `v` = 인자를 배열(vector) 형태로 받는다.
    
- `p` = PATH 환경변수에서 실행 파일을 찾아준다.
    

**execvp() 내부 흐름:**

1. 커널이 디스크에서 프로그램을 프로세스 메모리에 로드
    
2. 커널이 arglist/argv[]를 넘겨줌
    
3. 커널이 main(argc, argv) 호출해서 프로그램 시작
    

- 주의: execvp()가 성공하면 기존 프로그램은 사라지고 돌아오지 않음.
    

---

# execvp() 인자 규칙

- 첫 번째 인자 (argv[0]) = 실행할 파일 이름
    
- 중간 = 프로그램에 전달할 인자들
    
- 마지막 = NULL 포인터
    

---

# fork()

- 새로운 프로세스(Child Process)를 생성한다.
    
- Parent와 Child는 각각 **독립된 메모리 공간**을 가진다.
    
- 내용물(코드, 데이터)은 fork 순간에 복제된다.
    
- fork 이후 둘 다 **fork() 다음 줄부터** 실행한다.
    

**fork 시 커널이 하는 일:**

1. 새로운 메모리 공간 할당
    
2. 부모 프로세스 복사
    
3. 새로운 프로세스를 실행 테이블에 등록
    

---

# wait()

- 부모 프로세스가 `wait()`를 호출하면,
    
- 부모는 멈춰서(wait) 자식 프로세스가 종료될 때까지 기다린다.
    
- 자식 프로세스가 끝나면,
    
    - `wait(&status)`를 통해 PID와 종료 상태를 알 수 있다.
        

**status 16비트 구성:**

- 상위 8비트: exit 코드
    
- 1비트: core dump 발생 여부
    
- 하위 7비트: signal 번호 (비정상 종료된 경우)
    

---

# Signal 처리

- 프로세스에 시그널(Ctrl+C 등) 보내면,
    
- 부모와 자식 프로세스 모두 영향을 받을 수 있다.
---

# exit() vs _exit()

exit 함수는 프로세스 종료할 때 다양한 기능을 하고 _exit 시스템 콜을 호출함. _exit 는 커널 단에서 여러가지 기능을 하고 프로세스를 종료시킴. 

# _exit() procedural step

1. 현재 프로세스 종료 준비
    
2. 열린 파일 디스크립터 정리
    
3. 메모리 영역 해제
    
4. 자식 프로세스가 있다면 부모를 `init(1)` 프로세스로 변경
    
5. 부모 프로세스에게 SIGCHLD 신호 보냄
    
6. 종료 상태를 커널에 저장
    
7. 좀비 상태(Zombie)로 대기
    
8. 부모가 `wait()` 호출하면 최종적으로 소멸
    

---

# 좀비 프로세스

- 자식 프로세스가 `exit()`했지만,
    
- 부모 프로세스가 `wait()`를 호출하지 않으면,
    
- 커널 테이블에 "종료 상태 정보"만 남아서 살아있는 상태.
    
- 리소스 누출의 원인이 될 수 있음.

