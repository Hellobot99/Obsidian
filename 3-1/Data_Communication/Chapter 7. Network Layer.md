# Services

#### Packetizing

- 출발지에서 **payload를 네트워크 계층의 패킷으로 캡슐화(encapsulate)**하고
    
- 목적지에서 패킷을 디캡슐화(decapsulate)
    
- 목적지까지 payload를 **변경하지 않고 운반**하는 것이 목표

#### Routing

- 목적지까지의 경로 결정, 다음 라우터로 전송

#### Error Control

- **패킷이 라우터마다 분할(fragmented)** 될 수 있어서 에러 체크가 비효율적임
- **Checksum은 헤더만 검사**하며 전체 데이터그램은 검사하지 않음

#### Flow Control

- 데이터 전송 속도 조절

#### Congestion Control

- 너무 많은 데이터를 보내지 않도록 조절

#### Quality of Service

- 실시간 서비스의 경우 QoS가 더 필요함

#### Security

- 보안

---
# PERFORMANCE

## Delay

- Transmission delay
	패킷을 전송하는데 걸리는 시간
	packet length / transmission rate
	
- Propagation delay
	패킷이 가는데 걸리는 시간
	distance / propagation speed
	
- Processing delay
	라우터에서 처리하는데 걸리는 시간
	
- Queing delay
	라우터 큐에서 들어오고 나가는 시간

- Total delay = (n+1)(trd+pgd+prd) + (n)(qd)

## Throughput

- 1초에 몇 비트가 지나가는지

![[Pasted image 20250609114618.png]]
![[Pasted image 20250609114734.png]]

- backbone 에서는 전달 속도가 빨라서 보통 throughput은 TR1 or TR2

---

## IPv4 Addressing

- IP 주소는 connection의 주소, 호스트나 라우터가 아님

![[Pasted image 20250609115252.png]]

- Prefix 와 Suffix 로 나눠짐
	- Classful Addressing
	![[Pasted image 20250609115419.png]]
	- Classless Addressing
	![[Pasted image 20250609115909.png]]


![[Pasted image 20250609120135.png]]

- 네트워크 주소로 27비트를 쓰고 suffix로 5비트를 쓰니까 첫번째 주소는 마지막 5비트가 0인 주소

## Adress Mask

- 알고 싶은 비트만 추출하는 것
![[Pasted image 20250609135623.png]]

## Forwarding table

- 라우터가 사전에 네트워크 어드레스에 따라 어디로 보낼지 써둔 테이블

## Block Allocation

- **ICANN (Internet Corporation for Assigned Names and Numbers)**: 전 세계 IP 주소 블록 할당을 총괄하는 글로벌 기관.
    
- 하지만 **개별 사용자에게 직접 할당하지는 않음**.
    
- 대신 **ISP (인터넷 서비스 제공자)** 에게 큰 블록 단위로 할당.

- ex) 1000 개의 주소를 요청받는 경우, 1024개의 주소 -> 10개 비트로 네트워크 주소, 22개의 prefix 주소를 가짐. 
![[Pasted image 20250609140433.png]]

- ex) 14.24.74.0/24 에서 3개 (10, 60, 120) 의 서브블록을 설계. 2의 12제곱 개의 주소가 있음으로 첫 번째 주소는 14.24.74.0/24, 마지막 주소는 14.24.74.255/24 이고, 120, 60, 10 순으로 할당을 해줌. 128 개의 주소를 빼주면 14.24.74.0/25~14.24.74.127/25, 64개의 주소를 빼주면 14.24.74.128/26 ~ 14.24.74.191/26, 16개의 주소를 빼주면 14.24.74.192/28 ~ 14.24.74.207/28

## Address Aggregation

- 연속성을 갖는 주소를 합친거

![[Pasted image 20250609141455.png]]


## 여러가지 프로토콜

- IP : 메인 프로토콜
- ICMPv4 : 에러 발생 시 사용
- IGMP : 멀티캐스팅
- ARP : 주소 매핑

## Datagram Format

![[Pasted image 20250609141955.png]]

- VER(4비트): IP 버전(IPv4는 4)
    
- HLEN(4비트): 헤더 길이(4바이트 단위) 여기다 4 곱하면 길이 나옴
    
- Service type(8비트): 서비스 유형(우선순위, DiffServ)
    
- Total length(16비트): 전체 길이(헤더+데이터, 바이트 단위) 
    
- Identification, Flags, Fragmentation offset: 단편화 관련 정보
    
- Time-to-live(TTL, 8비트): 패킷의 최대 라우터 수(수명) 라우터 지날때마다 1씩 감소 0 이면 폐기
    
- Protocol(8비트): 상위 계층 프로토콜 지정(TCP, UDP 등)
    
- Header checksum(16비트): 헤더 오류 검출
    
- Source/Destination IP address(각 32비트): 출발지/목적지 IP
    
- Options + padding(0~40바이트): 선택적 필드

Length of data =Total length - (HLEN) * 4 

- **Example 7.7**  
    IPv4 패킷의 처음 8비트가 (01000010)₂일 때,
    
    - 앞 4비트(0100)는 버전(IPv4)으로 올바르지만,
        
    - 다음 4비트(0010)는 헤더 길이(HLEN)로, 2 × 4 = 8바이트를 의미함.
        
    - IPv4 헤더 최소 길이는 20바이트이므로, 이 값은 잘못된 것.
        
    - 전송 중 패킷이 손상되어 수신자가 패킷을 폐기함1.
        
- **Example 7.8**  
    HLEN 값이 (1000)₂ = 8인 IPv4 패킷에서,
    
    - 헤더 전체 길이는 8 × 4 = 32바이트.
        
    - 이 중 20바이트는 기본 헤더, 나머지 12바이트는 옵션 필드
	    
- **Example 7.9**  
    HLEN이 5, Total Length가 0x0028(16진수)인 IPv4 패킷에서
    
    - 헤더 길이: 5 × 4 = 20바이트
        
    - 전체 길이: 0x0028 = 40바이트
        
    - 데이터 길이: 40 - 20 = 20바이트1
        
- **Example 7.10**  
	45000028000100000102... 일때
    IPv4 패킷의 9번째 바이트(TTL)가 0x01이므로, 이 패킷은 1홉만 이동 가능
    
    - 10번째 바이트(Protocol)가 0x02로, 상위 계층 프로토콜은 IGMP임
        
- **Example 7.11**  
    IPv4 헤더의 체크섬 계산 예시
    
    - 16비트 단위로 쪼개 모두 더한 뒤, 왼쪽 자리수의 캐리값을 더함
        
    - 결과를 보수(FFFF에서 뺌)하여 체크섬 필드에 삽입
    
	![[Pasted image 20250609145633.png]]

# Fragmentation

#### MTU (Maximum Transfer Unit)

- 캡슐화 할 수 있는 최대의 크기(헤더 포함X)
- 이거보다 작아야 전송 가능

#### Fields Related to Fragmentation

- **Identification 필드(16비트):**
    
    - 데이터그램의 출발지에서 고유하게 식별
        
    - 각 데이터그램마다 고유 번호를 부여해, 단편화 시 모든 조각에 동일한 번호가 복사됨
        
    - 같은 번호를 가진 조각들은 하나의 데이터그램으로 재조립됨
        
- **Flags 필드(3비트):**
    
    - 첫 번째 비트: 예약(사용하지 않음)
        
    - 두 번째 비트(D bit, do not fragment): 1이면 단편화 금지(불가할 경우 ICMP 오류 반환), 0이면 필요시 단편화 허용
        
    - 세 번째 비트(M bit, more fragment): 1이면 추가 조각이 더 있음, 0이면 마지막 조각임
	    
- **fragmentation offset 필드(13비트)**:
    
    - 단편화된 데이터그램 조각이 원래 데이터그램에서 어디 위치인지 표시
        
    - 8바이트 단위로 오프셋 값을 가짐(예: 1400바이트면 1400/8=175)
        
    - 13비트이므로 8191 × 8 = 65528바이트 이상은 표현 불가
        
- **예시(4000바이트 데이터그램 단편화)**
    
    - 첫 번째 조각: 0~1399바이트, 오프셋=0
        
    - 두 번째 조각: 1400~2799바이트, 오프셋=175
        
    - 세 번째 조각: 2800~3999바이트, 오프셋=350
	![[Pasted image 20250609151212.png]]
- 각 조각의 오프셋 값은 해당 조각의 첫 바이트가 원본 데이터그램에서 몇 번째 위치인지 8로 나눈 값임

![[Pasted image 20250609151546.png]]

## 예제 7.12

**문제 요약:**  
M 비트가 0인 패킷이 도착했다. 이 패킷이 첫 조각, 마지막 조각, 중간 조각 중 무엇인지? 패킷이 단편화됐는지 알 수 있는가?

**해설 요약:**  
M=0이면 더 이상 조각이 없으므로 마지막 조각이다. 그러나 원래 단편화된 패킷인지(즉, 여러 조각 중 마지막인지) 아니면 단편화되지 않은 패킷인지 알 수 없다. 단편화되지 않은 패킷도 마지막 조각으로 간주된다.

---

## 예제 7.13

**문제 요약:**  
M 비트가 1인 패킷이 도착했다. 이 패킷이 첫 조각, 마지막 조각, 중간 조각 중 무엇인지? 패킷이 단편화됐는지 알 수 있는가?

**해설 요약:**  
M=1이면 이후에 더 조각이 있으므로 마지막 조각은 아니다. 이 패킷은 첫 번째 조각이거나 중간 조각일 수 있다. 어느 쪽인지는 offset 값을 추가로 알아야 구분할 수 있다.

---

## 예제 7.14

**문제 요약:**  
M 비트가 1, offset 값이 0인 패킷이 도착했다. 이 패킷이 첫 조각, 마지막 조각, 중간 조각 중 무엇인가?

**해설 요약:**  
M=1이므로 첫 번째 또는 중간 조각이지만, offset=0이므로 첫 번째 조각이다.

---

## 예제 7.15

**문제 요약:**  
offset 값이 100인 패킷이 도착했다. 첫 바이트 번호는? 마지막 바이트 번호도 알 수 있는가?

**해설 요약:**  
첫 바이트 번호는 offset × 8 = 800번이다. 마지막 바이트 번호는 데이터 길이를 알아야 계산할 수 있다.

---

## 예제 7.16

**문제 요약:**  
offset=100, HLEN=5, total length=100인 패킷이 도착했다. 첫 바이트와 마지막 바이트 번호는?

**해설 요약:**  
첫 바이트 번호는 100 × 8 = 800.  
헤더 길이(5 × 4 = 20바이트)를 제외한 데이터 길이는 100 - 20 = 80바이트.  
따라서 마지막 바이트 번호는 800 + 80 - 1 = 879이다