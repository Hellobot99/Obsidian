
## 소개

- 시스템 프로그래밍 수업에서는 시스템 콜을 자주 사용한다.

- 응용 프로그램 개발에서도 시스템 콜은 뒤에서 작동한다.

- 오늘 배울 내용:

  - 시스템 콜이 존재하는 이유

  - 시스템 콜의 동작 방식

  - OS가 CPU를 가상화하는 방법 (프로세스 추상화, 제한된 직접 실행, 스케줄링)  

## 참고자료

- Operating Systems: Three Easy Pieces (OSTEP)

  - Remzi H. Arpaci-Dusseau, Andrea C. Arpaci-Dusseau  

---
  
# 1. 여러 프로그램을 동시에 실행하는 방법

  
- 현대 시스템은 수십~수백 개의 프로세스를 동시에 실행하는 것처럼 보인다.

- OS가 CPU를 가상화하여 여러 프로세스가 CPU를 공유하게 한다.

  
## CPU 가상화

- **프로세스**: 실행 중인 프로그램

- **타임 쉐어링(Time Sharing)**: 하나의 프로세스를 잠시 실행하고 다른 프로세스로 전환하는 방식.

- OS는 두 가지가 필요:

  - **메커니즘** (예: 컨텍스트 스위칭 방법)

  - **정책** (예: 어떤 프로세스를 실행할지 결정)  

---
# 2. 프로세스의 구성요소


- 메모리(주소 공간)

- 레지스터 (프로그램 카운터, 스택 포인터 등)

- 저장소 접근 (예: 파일)

---

# 3. 프로세스 생성 단계

  
1. 프로그램 코드를 메모리에 적재

2. 런타임 스택 할당

3. 힙 메모리 할당

4. I/O 초기화 (stdin, stdout, stderr)

5. `main()` 진입점에서 실행 시작

---

# 4. 프로세스의 메모리 레이아웃

  

- 텍스트(코드), 데이터(글로벌 변수), 힙(동적 메모리), 스택(임시 데이터)

---  

# 5. 시스템 콜과 트랩

  

- 사용자 프로그램이 커널 기능(예: 파일 접근)을 요청할 때 **시스템 콜** 사용.

- 특별한 명령어(트랩)를 통해 커널 모드로 진입한다.

- 트랩 핸들러가 호출되어 요청을 처리한 후, 다시 사용자 모드로 복귀.

  

> x86에서: `INT` 명령어로 트랩, `IRET` 명령어로 복귀


---

# 6. 제한된 직접 실행 (Limited Direct Execution)

  

- 프로그램을 직접 CPU에서 실행시켜 성능을 높임.

- 하지만 OS는 여전히 CPU 제어를 위해

  - 시스템 콜 트랩

  - 타이머 인터럽트를 사용.

---

# 7. 프로세스 간 전환 (Context Switch)


- 스케줄러가 현재 프로세스의 레지스터 상태를 저장.

- 새 프로세스의 레지스터를 복구.

- OS가 제어를 계속 가지기 위해 타이머 인터럽트 사용.

  
---

# 8. 예제: 시스템 콜 사용


```c

#include <stdio.h>

#include <unistd.h>

  

int main() {

    printf("Hello, World!\n"); // printf는 내부적으로 write 시스템 콜을 사용

    _exit(0); // _exit은 시스템 콜 exit() 호출

}

```

  

> `printf()`는 내부적으로 `write()` 시스템 콜을 호출해서 출력한다.  

> `_exit()`은 직접 시스템 콜을 호출하여 프로그램을 종료한다.