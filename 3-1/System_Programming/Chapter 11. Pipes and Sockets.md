# Pipe
#### 개념

- **단방향 통신 채널**, 커널이 관리.
    
- 한 쪽은 쓰기(write), 다른 쪽은 읽기(read)에 사용.
    
- **프로세스 간 통신 (IPC)** 용도로 사용.
    
- 예: `who | sort` — `who`의 출력을 `sort`가 입력으로 받음.

#### 생성 방법

- `pipe(int fd[2])` 함수 사용: `fd[0]`은 읽기, `fd[1]`은 쓰기용.

#### fork와 함께 사용하는 경우

- `pipe()`로 파이프 생성 후 `fork()` 호출하면, 부모와 자식 프로세스가 **동일한 파이프**를 공유함.
    
- 한쪽은 쓰고, 다른 쪽은 읽는 방식으로 사용.

![[a9.png]]

#### Reading from Pipes

- 블로킹
	
- 쓰기가 닫히면 0을 받음
	
- 한번 읽은 데이터는 사라짐

#### Writing from Pipes

- 파이프가 가득 차면 빈 공간이 생길 때까지 대기
	
- 읽기 쪽이 닫힌 경우 SIGPIPE 시그널 발생

#### 장점

- 간단하고 사용 쉬움
    
- 네트워크 설정 불필요

#### 단점

- `fork()`로 생성된 **관련 프로세스끼리만 사용 가능**
    
- **같은 머신 내에서만** 통신 가능 → 원격 통신 불가

---
# NTP Service

- 컴퓨터 끼리 시간을 동기화 해줌.

#### 서버

- 소켓 생성 -> bind -> listen -> accept -> read/write -> close

#### 클라이언트

- 소켓 생성 -> connect -> read/write -> close

### NTP 서버의 동작 원리

1. `socket()` 호출 → 커널에 소켓 요청
    
2. `bind()` 호출 → IP 주소 + 포트 번호 지정
    
3. `listen()` 호출 → 대기 상태로 전환
    
4. `accept()` → 클라이언트 요청 수락
    
5. `read()` / `write()` → 데이터 주고받기
    
6. `close()` → 소켓 닫고 연결 종료

### NTP 클라이언트의 동작

1. `socket()`으로 소켓 생성
    
2. `connect()`로 서버 접속
    
3. 서버로부터 `read()` 호출로 데이터 수신
    
4. `close()`로 연결 종료

---

# 웹 서버

### 웹 서버가 하는 일

1. **프로그램 실행**: PHP 등 스크립트 실행
    
2. **파일 제공**: HTML, 이미지 등 정적 파일 제공
    
3. **디렉토리 목록 제공**: 폴더 내부 보여주기

### HTTP Request 구조

1. **Command**: GET, POST 등
2. **Argument**: 요청한 파일 경로 (예: /index.html)
3. **Protocol version**: HTTP/1.0, HTTP/1.1 등

### HTTP Reply 구조

1. **Status Line**: 예) HTTP/1.0 200 OK
2. **Headers**
3. **Blank Line**
4. **Content**: 요청된 리소스 내용

---

### 웹 서버 동작 순서

1. **서버 소켓 생성** (`socket()`)
    
2. **연결 대기** (`listen()` + `accept()`)
    
3. **요청 읽기** (`read()`)
    
4. **요청 처리**
    
    - 파일 열기 → `open()`, `read()`
        
    - 없으면 오류 응답
    
5. **응답 전송**
    
    - 상태 줄 + 헤더 + 본문 (`write()`)
    
6. **연결 종료** (`close()`)